הסבר על פרוקטוקול TCP
-------------------------------

פרוטוקול הTCP הינו פרוטוקול המוגדר בשכבה 4 במודל הOSI ובשכבה 3 במודל הTCP/IP
הפרוטוקול הזה מוגדר כפרוקטוקול אמין ובמונח מיקצועי connection orianted 

כשאומרים אמין מתכוונים שהוא למעשה בודק ומוודא שכל מידע שנשלח מנקודה א  אכן הגיע ליעדו בנקודה ב ואם לא הגיע הוא מבצע שליחה מחדש בין שני הנקודות
בנוסף כל מידע שנשלח הוא ממספר מה שאומר שאם חבילה מסויימת של מידע הגיעה לפני חבילה אחרת אזי לפי המספור מקבל ההודעות יכול לדעת מה נשלח לפני מה במקור

בתחילת שיחה בין שני משתמשים אנו נראה ביצוע three-way handshake שמשומש על ידי TCP
1. יוזם השיחה שולח בקשה לצד השני (מקבל השיחה) כאשר דגל הSYN מופעל וערכים נוספים כגון window size value וגם MSS 
2. מקבל הבקשה שולח אימור על הבקשה שהתקבלה וזה נקרא ACK ושולח גם הוא SYN לצד היוזם ועוד ערכים נוספים כגון window size value וגם MSS
3. יוזם השיחה מקבל את האישור שהתקבל מהצד השני ושולח אישור על החבילה שהגיע כלומר יש רק ACK והפעם בערכים של Sequences וגם acknolagment יש לנו ערך 1 ולא נמצא בחבילה זאת ערכים כגון MSS אבל כן נוכל לראות window size value
 

תעבורת המידע מתבצעת בשני שלבים שחוזרים על עצמם לעל אורך השיחה
1. צד א ששולח את המידע ממספר את החבילות שהוא מעביר ושולח גם את את הנתון המצביע על גודל  החבילה LEN בנוסף אנו נמצא בחבילה זאת ערכים לשדות כמו seq u-ACK  שהם משתמשים להמשך שיחה תקינה בין שני הצדדים, אם משהו מהערכים לא טואם למה שצריך להתקבל אזי אנו יודעים שיש בעיה ומבקשים לקבל את החבילה 
2. צד ב שולח תגובה על החבילה  התקבלה מצד א התגובה תכיל אישור על קבלת המידע וערך מספרי של seq כלומר ערך הACK לדוגמא יהיה  שווה ל4 אם הערכים השתקבלו מצד א הם len=3 seq=1, ישנם שני חוקים איך ערך הACK וערך הSEQ עובד והם:
	ה- ACK = גודל המידע שקיבלתי + הערך המספרי שקיבלתי בseq שצויין בחבילה
	ה- SEQ = גודל המידע ששלחתי + הערך המספרי הקודם ששלחתי בseq


ברגע שצד אחד מעוניין לסיים קשר כזה או אחר מצד שני הוא מתחיל בתהליך הבא:
1. שליחת הודעה מצד א המכילה את הערכים FIN וגם ACK  ערך FIN  מציין על רצון לסגור את השיחה והערך ACK מאשר את החבילה הקודמת שנשלחה
2. הצד המקבל שולח אישור על בקשת סגירות ההודעה
3. הצד המקבל שולח גם הוא חבילת סגירת הודעה המכילה את הערכים ACK FIN 
3. צד א שולח אישור על סגירת השיחה שהתקבל מהצד השני



נעבור להתבונן על החבילה עצמה של TCP
-------------------------------------

  TCP Header Format


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




פורט מקור - הפורט שיוזם השיחה מגריל בין המספרים 49152-65535 והוא משמש אותנו כמו שעובד IP רק בשכבות היותר גבוהות כלומר ברמת האפליקציה לדעת איזה אפליקציה במכונה שלנו יזמה את השיחה שאליה פורט זה למעשה ישוייך
פורט יעד - הפורט שהיוזם מציין בחבילה כדי לצייןן איזה שירות הוא מעוניין לקבל מהיעד שלו הפורטים הללו הן בין 0-1023, כל פרוקטוקול שמשתמש בTCP יש לו פורט משל עצמו, פרוטוקולים לדוגמא והפורטים שלהם:
HTTP-80, FTP-20,21, telnet-23, ssh-22, SMTP-25,

מספר סידורי Sequence number - זהו מספר שמחושב בצד השולח עם כל שליחה שהוא מבצע, הכלל כדי לבצע את החישוב הוא:
	 - גודל המידע ששלחתי בבייטים + הערך המספרי של הseq הקודם ששלחתי = SEQ הנוכחי

מספר אישור Acknowledgment number - הערך המספרי לאישור החבילות שהתקבלו, גם פה יש חישוב מסויים המציין את אותן חבילות שקיבלנו, כלומר שלפי אישור זה הצד השולח יודע להגיד מה התקבל בצד השני ומה לא והחישוב עובד באופן הבא:
	-גודל המידע שקיבלתי בבייטים + הערך המספרי של הSEQ שקיבלתי = ACK הנוכחי

מידע על אורך החבילה - שדה זה יכיל מידע על אורך החבילה, השדה הזה מורכב מ4 ביטים, על פי רוב הוא ייציין 8 שזה אומר שאומדים להיות שימוש ב32 בייטים 
כלומר הגודל הכולל של חבילת הTCP הינה 32 בייטים שזה 256 ביטים וסביר להניח שבחבילה כזאת נמצא את שדה option בשימוש,לפעמים נמצא שמסגרת זאת מכילה את הספרה 5 שזה אומר 20 בייטים שסביר להניח במסגרת זאת אין לנו option 

מידע שמור Reserved - מדובר על 3 ביטים שמורים, בעבר היה מדובר על 6, 3 מהם משמשים היום לדגלים חדשים כגון NS, CWR, ECE

דגלים flags - כיום יש לנו 9 דגלים והם:
	3 הדגלים הראשונים קשורים לECN שזה אומר Explicit Congestion Notification שהם נועדו למנוע התנגשות ברמת TCP ברשת

	בתחילה שיצרו את פרוטוקול TCP כפי שמצויין בRFC793 שנכתב ב1981, הפרוטוקול הכיל 6 ביטים שהיו שמורים, לאחר מכן נערך מחדש ונכתב rfc3168 בשנת 2001 ובו הוצגו לראשונה שימוש בשני ביטים מתוך ה6 שהיו שמורים, הם שומשו כדי לתת מענה לבעיית עומסים ברשת, עד נקודה זאת אם היה עומס החבילות היו נזרקות, כעת בזכות שני ביטים אלו ציוד הנמצא בתווך יכול לסמן את חבילות המידע, סימון זה אומר לצדדים המשתתפים בקישור שיש עומס בנקודה כלשהי בתווך ולכן יש להאט את זרימת המידע בין שני הצדדים שעובדים עם TCP,
עקרונית זה עובד באופן הבא:

	בעת הקמת שיחה בין שני הצדדים נעשה משא ומתן על אפשור הECN, ובמידה ושני הצדדים תומכים בזה בחבילות יצויין ברמת הIP בשדה diffserv שניתן להשתמש בENC על ידי ערך ECT שאלו שני הביטים האחרונים בdiffserv.
	נניח שנתב בתווך מזהה שיש עומס והתנגשות במצב הרגיל הנתב היה זורק את החבילות, במצב העכשווי הנתב רואה שיש ביט ECT ולכן הוא יגדיר בחבילה בשדה הIP את ביט הCE ויעביר את החבילה, מקבל החבילה יראה כי מוגדר ברמת הIP ביט CE וישלח ECN-echo לצד השולח 
הצד השולח יקבל את החבילה עם ECN-echo ויתנהג בהתאמה להתנגשות שהתרחשה ברשת כאילו חבילות נזרקו, מה שאומר שקצת העברת המידע יואט
בחבילת המידע הבאה שישלח השולח הוא יסמן את ביט CWR שמאשר שהוא קיבל את ביט ENC-echo.
בrfc3540 שנכתב ב2003 הוסיפו ביט נוסף שישמש את המנגנון הזה מפני שביטים בשדה בdiffserv יכולים לדרוס את ECT (נניח שימוש בQOS) ולכן יש לנו ביט נוסף בשם NS שאומר שיש אפשרות להשתמש בENC כדי לזהות התנגשות ברשת

לסיכום:
	- ביט NS - משמש אותנו כדי לאפשר שימוש במנגנון של ENC למקרה של התנגשויות
	- ביט CWR - Congestion Window Reduced - זהו ביט הנועד להוריד את ערך החבילה מגודלה לאחר שהתנגשות התרחשה
	-ביט ENE - לביט זה יש שני תפקיד בהתחשב בדגל SYN
		- אם הSYN מוגדר על 1 זה אומר שיש תמיכה בECN
		- אם הSYN מוגדר על 0 אזי אם ECN מוגדר ברמת הIP אנחנו יודעים שהתרחשה התנגשות ברשת ולכן נתחיל להוריד את קצת שליחת המידע


	דגל דחוף URG - המציין שקרה משהו שצריך לעדכן עליו באופן מיידי - דוגמא לדגל כזה נניח התחלשי להעביר קבצים בFTP ובאמצע הרגתי את השיחה, במקרה כזה הדגל הזה ישומש 
 	דגל  ACK - משמש לאישור המידע שהתקבל
	דגל PSH - משמש לדחוף  מידע לצד המקבל, סביר להניח שאם נראה את דגל זה פעיל אזי יש לנו מידע מעל הTCP שמיועד לאפליקציה בצד השני
	דגל RST - דגל המשמש לאתחל את השיחה, אם דגל זה מופיע אזי הצד ששלח דגל זה מבין שמשהו קרה ומבקש לומר לו שיעצור את השיחה ולא יקבל יותר חבילות שהוא מצפה להן, למעשה זה הורד את השיחה ברמת TCP
	דגל SYN - למעשה זה דגל שנכרון והוא מופיע בתחילת שיחה three-way handshake
	דגל FIN - דגל המבקש לסגור שיחה מול הצד השני

גודל החלון Window size - שדה זה יגיד לצד המקבל כמה אנחנו יכולים לקלוט מידע לפני שהצד השולח יעצור ויצפה לקבל אישור על כל מה שהוא שלח
כלומר אם נניח ייצויין בשדה הזה 45K זה אומר שהצד השני רשאי לשלוח לנו 45K לפני שיעצור וימתין לקבל אישור על המידע שכבר שלח... כלומר אם הוא יגיע ל45K הוא חייב לעצור ולהמתין לקבלת אישור שהתקבל ה45K בהצלחה לפני שימשיך לשלוח, חשוב לזכור שלא תמיד הצד המקבל ימתין עד שיתקבלו כל ה45K כלומר יתכן שאם יתקבלו רק 20K הוא כבר ישלח אישור על כל ה20K, השדה הזה אומר למעשה מה הגג שאנחנו יכולים לבל לפני שאנחנו מאשרים את כל מה שקיבלנו

בדיקת שגיאות - Checksum - שדה זה הינו מגניב ביותר בגלל שהוא בודק שאין שגיאות בחבילה שהתקבלה, כלומר סוג של ווידוא שהחבילה שהתקבלה הינה התקבלה כמו שהיא נשלחה, אם נעשה שינוי לחבילה בדרך אזי היא לא תעבור Checksum כראוי ולכן נשליך אותה
בדיקת השגיאה במתבצעת באופן מסויים ומכילה את כל הערכים הבאים לחישוב

ערך הפסודו:
	-כתובת מקור של השולח מחבילת הIP
	-כתובת יעד של השולח מחבילת הIP
	-שדה שמור של מידע שמונה ביטים שהם 0
	-סוג הפרוטוקול שמצויין בחבילת הIP
	-גודל שדה הTCP - מחושב, כלומר אם זה 28 אז צריך להמיר את זה לHEX שזה 1c 

הערכים של כל שדה הTCP
	-פורט המקור
-	-פורט היעד
	-מספר הסידורי seq
	-מספר הסידורי ACK
	-שדות הData Offset, reserved and Flags
	-שדה של UGN אם הדגל של URG מוגדר אזי שדה זה ילקח בחשבון אם לא אז הכל זה 0 גם ככה
	-שדה window size
	-במקרה ויש option הוא ילקח בחשבון

נעשה חישוב מהיר כדי לראות איך זה מתבצע

source address 0a00
source address 0006
destination address 0a00
destination address 0007
reserved data and protocol type 0006 - זה תמיד יהיה 6 כי מדובר על TCP
the size of TCP header 001e - למעשה הגודל של החבילה היא 32 בטים ולכן נמיר את זה בהאקס וזה מה שייצא לנו
source port 0015
destination port e9bd
seq number 27b9
seq number 355f
ack number 2c1e
ack number dc1c
Data Offset, reserved and Flags 8012
window size 2000
option 0204
option 05b4
option 0103
option 0308
option 0101
option 0402

נחבר הכל במחשבון ונראה מה ייצא לנו
check = 0a00 + 0006 + 0a00 + 0007 + 0006 + 001e + 0015 + e9bd + 27b9 + 355f + 2c1e + dc1c + 8012 + 2000 + 0204 + 05b4 + 0103 + 0308 + 0101 + 0402


3142D
לאחר שיש לנו את התוצאה שהיא 3142D נוסיף את 3 לD שיש לנו כאילו אנחנו עושים 0003 + 498D
נקבל את הערך 4990  ואז צריך לעשות היפוך לכל הביטים לדוגמא אם יש לנו את הביטים 0010 אז עכשיו זה יהיה 1101 (היפוך)
אם כן הערך הבינארי למה שיש לנו הוא 0100100110010000
הערך ההפוך לזה הינו 1011011001101111

בערך של האקסה זה יוצא 366F

checksum = ebcd


















	



